{"arch":"<p>Ripple.js состоит из </p>\n<ul>\n<li><code>API</code> — фасада</li>\n<li>Функций привязки(создающих несколько <code>eventListner</code> и хендлеры для создания \\ скрытия ripple эффектов)</li>\n<li><code>Ripple</code> — класса, создающего один эффект</li>\n<li><code>RippleFactory</code> — фабрики, производящие Ripple</li>\n<li>И маленьких полифиллов для старых, но уже поддерживающих CSS3 браузеров </li>\n</ul>","bad":"<h3 id=\"api\">API (опять)</h3>\n<p>Местами API является ограниченным, хотя сделать, например, возможность появления ripple на mousein \\ mouseout была</p>","good":"<h3 id=\"api\">API</h3>\n<ul>\n<li>Простое: <code>ripple.watch(selector, props)</code></li>\n<li>Позволяет менять свойста эффекта постфактум</li>\n<li>Позволяет привязывать ripple к элементам напрямую (для компонентов и подобного)</li>\n</ul>\n<h3 id=\"dom\">Отсутвие DOM иньекций</h3>\n<p>Я уже видел удивительных людей, которые придумали использовать его \nна <code>&lt;input /&gt;</code>, это явно дает +10 к гибкости и пресказуемости</p>","overview":"<p>Единственная реализация Material Design Ripple Effect, которая не лезет в элементы, на которых запускается.</p>\n<p>Вероятно, с самым простым API.</p>","role":"<p>Всё: проектирование, разработка, демо страница, поддержка</p>","skills":"<h3 id=\"es6\">ES6</h3>\n<p>Классы, arrow функции, import и другие упрощающие жизьнь нововведения</p>\n<h3 id=\"css3\">CSS3</h3>\n<p>Ripple основывается на производительности CSS3 <code>transfrom</code> &amp; <code>transition</code> и том, что они триггерят только paint в браузере</p>\n<p>Также позволяют комфортно управлять ходом анимации с помощю собственный <code>timing-function</code> (что включает в себя много боли при создании JS анимаций)</p>\n<h3 id=\"webpack\">Webpack</h3>\n<p>создание конфигасобирает проект под lib экспорт, ES6-&gt;E55 при помощи babel</p>\n<h3 id=\"apidesign\">API Design</h3>\n<p>Т.к. ripple создан для интерактивных областей, API решено поместить в JS, а не привязывать классом + use case с фреймворками</p>\n<p>Ручную привязку у ивентам я считаю избыточной, т.к. в документации Material Design use case Ripple описан однозначно</p>\n<h3 id=\"\">Дизайн</h3>\n<p>Демо страница, подчеркивающая его сильные стороны Ripple.js </p>\n<h3 id=\"mochachaiphantomjs\">Тестирование: Mocha, Chai, Phantom.js</h3>\n<p>Тесты написаны используая mocha + Chai </p>\n<h3 id=\"devtools\">Devtools</h3>\n<p>У одного из людей, использовавших Ripple.js возник странный баг с смещением на несколько пикселей, слава брейкпоинтам, мне удалось выяснить, что дело в сколлбаре, который появлялся при появлении Ripple</p>","takeaways":"<h3 id=\"scalingup\">Scaling Up</h3>\n<p>Если надо увеличивать элемент, то лучше сразу сделать элемент финального размера, посавить ему в начале анимации <code>transform: scale($startSize/$finalSize)</code>, это позолит сохранить контур четким (да, это частный случай <a href=\"https://aerotwist.com/blog/flip-your-animations/\">FLIP</a>\n(пример на Sass для удобочитаемости)  </p>\n<h3 id=\"eventwhatevent\">Event, what event?</h3>\n<p>Многие <code>mousevent</code> игнорируются при смене окон и во время выделения текста</p>\n<h3 id=\"notyetabsolute\">Not yet absolute</h3>\n<p>До того, как элемент получит расстояние до одного из направлений <code>postition: absolute</code> (и <code>fixed</code>) не выдеренет его из layout.</p>\n<h3 id=\"rtl\">RTL</h3>\n<p><code>direction: rtl</code> заставляет <code>.getBoundingClientRect</code> видеть мир в несколько иных красках</p>","title":"Ripple.js","url":"ripple-js","links":{"demo":"https://vsevolodtrofimov.github.io/Ripple.js/","source":"https://github.com/VsevolodTrofimov/Ripple.js"},"description":"Material design ripple effect"}
